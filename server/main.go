package main

import (
	"encoding/binary"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"os"
	"reflect"
	"sync"
	"time"
	"unicode/utf16"
)

const (
	PORT     = "20000" // TCP Port
	API_URL  = "http://192.168.1.125:3000/api/speakers"
	USE_MOCK = true // true = ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• mock, false = ‡πÉ‡∏ä‡πâ API ‡∏à‡∏£‡∏¥‡∏á
)

// ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å API
type Speaker struct {
	ID            int    `json:"id"`
	Name          string `json:"name"`
	SeatName      string `json:"seatName"`
	Prio          bool   `json:"prio"`
	PrioOn        bool   `json:"prioOn"`
	ParticipantID int    `json:"participantId"`
	MicOn         bool   `json:"micOn"`
}

var (
	mockMicState = true
	lastToggle   = time.Now()
)

// Client ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á client ‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
type Client struct {
	conn net.Conn
	id   int
}

// Server ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Ç‡∏≠‡∏á clients
type Server struct {
	clients    map[int]*Client
	nextID     int
	clientLock sync.Mutex
}

// ‡∏™‡∏£‡πâ‡∏≤‡∏á Server ‡πÉ‡∏´‡∏°‡πà
func NewServer() *Server {
	return &Server{
		clients: make(map[int]*Client),
		nextID:  1,
	}
}

// ‡πÄ‡∏û‡∏¥‡πà‡∏° client ‡πÉ‡∏´‡∏°‡πà
func (s *Server) AddClient(conn net.Conn) *Client {
	s.clientLock.Lock()
	defer s.clientLock.Unlock()

	client := &Client{
		conn: conn,
		id:   s.nextID,
	}
	s.clients[s.nextID] = client
	s.nextID++

	fmt.Printf("üë• Client %d ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠: %s\n", client.id, conn.RemoteAddr())
	return client
}

// ‡∏•‡∏ö client
func (s *Server) RemoveClient(id int) {
	s.clientLock.Lock()
	defer s.clientLock.Unlock()

	if client, exists := s.clients[id]; exists {
		fmt.Printf("üëã Client %d ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠: %s\n", id, client.conn.RemoteAddr())
		client.conn.Close()
		delete(s.clients, id)
	}
}

// ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ó‡∏∏‡∏Å clients
func (s *Server) Broadcast(data []byte) {
	s.clientLock.Lock()
	defer s.clientLock.Unlock()

	disconnectedClients := []int{}

	for id, client := range s.clients {
		_, err := client.conn.Write(data)
		if err != nil {
			fmt.Printf("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏¢‡∏±‡∏á Client %d: %v\n", id, err)
			disconnectedClients = append(disconnectedClients, id)
		}
	}

	// ‡∏•‡∏ö clients ‡∏ó‡∏µ‡πà‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
	for _, id := range disconnectedClients {
		go s.RemoveClient(id)
	}
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• API
func getMockSpeakers() ([]Speaker, error) {
	// ‡∏™‡∏•‡∏±‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÑ‡∏°‡∏Ñ‡πå‡∏ó‡∏∏‡∏Å 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
	if time.Since(lastToggle) >= 5*time.Second {
		mockMicState = !mockMicState
		lastToggle = time.Now()
		fmt.Printf("üîÑ ‡∏™‡∏•‡∏±‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÑ‡∏°‡∏Ñ‡πå‡πÄ‡∏õ‡πá‡∏ô: %v\n", mockMicState)
	}

	return []Speaker{
		{
			ID:            3539,
			Name:          "A05",
			SeatName:      "A05",
			Prio:          false,
			PrioOn:        false,
			ParticipantID: 0,
			MicOn:         mockMicState,
		},
	}, nil
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á API ‡∏à‡∏£‡∏¥‡∏á‡∏´‡∏£‡∏∑‡∏≠ mock)
func getSpeakers() ([]Speaker, error) {
	if USE_MOCK {
		return getMockSpeakers()
	}

	resp, err := http.Get(API_URL)
	if err != nil {
		return nil, fmt.Errorf("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö API: %v", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å API: %v", err)
	}

	var speakers []Speaker
	if err := json.Unmarshal(body, &speakers); err != nil {
		return nil, fmt.Errorf("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• JSON: %v", err)
	}

	return speakers, nil
}

// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏õ‡∏•‡∏á string ‡πÄ‡∏õ‡πá‡∏ô UTF-16LE with BOM
func toUTF16LEString(s string) []byte {
	// ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô UTF-16LE
	u16 := utf16.Encode([]rune(s))

	// ‡∏™‡∏£‡πâ‡∏≤‡∏á buffer ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö BOM ‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
	bytes := make([]byte, 2+len(u16)*2)

	// ‡πÉ‡∏™‡πà BOM (0xFF 0xFE ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö UTF-16LE)
	bytes[0] = 0xFF
	bytes[1] = 0xFE

	// ‡πÅ‡∏õ‡∏•‡∏á []uint16 ‡πÄ‡∏õ‡πá‡∏ô []byte
	for i, v := range u16 {
		bytes[2+i*2] = byte(v)
		bytes[2+i*2+1] = byte(v >> 8)
	}

	return bytes
}

// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô generateDiscussionXML
func generateDiscussionXML(speakers []Speaker) []byte {
	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÑ‡∏°‡∏Ñ‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
	hasMicOn := false
	participantsXML := ""

	for _, speaker := range speakers {
		if speaker.MicOn {
			hasMicOn = true
			participantXML := fmt.Sprintf(`<ParticipantContainer Id="%d"><Seat Id="%d"><SeatData Name="%s" MicrophoneActive="true" SeatType="Delegate" IsSpecialStation="false" /><IsReposnding>false</IsReposnding></Seat></ParticipantContainer>`,
				speaker.ParticipantID,
				speaker.ID,
				speaker.SeatName,
			)
			participantsXML += participantXML
		}
	}

	var xmlStr string
	if !hasMicOn {
		xmlStr = fmt.Sprintf(`<?xml version="1.0" encoding="utf-8"?><DiscussionActivity xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Version="1" TimeStamp="%s" Topic="Discussion" Type="ActiveListUpdated"><Discussion Id="71"><ActiveList></ActiveList></Discussion></DiscussionActivity>`,
			time.Now().Format("2006-01-02T15:04:05.0000000-07:00"),
		)
	} else {
		xmlStr = fmt.Sprintf(`<?xml version="1.0" encoding="utf-8"?><DiscussionActivity xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Version="1" TimeStamp="%s" Topic="Discussion" Type="ActiveListUpdated"><Discussion Id="71"><ActiveList><Participants>%s</Participants></ActiveList></Discussion></DiscussionActivity>`,
			time.Now().Format("2006-01-02T15:04:05.0000000-07:00"),
			participantsXML,
		)
	}

	return toUTF16LEString(xmlStr)
}

// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô generateSeatXML
func generateSeatXML(speaker Speaker, micState bool) []byte {
	xmlStr := fmt.Sprintf(`<?xml version="1.0" encoding="utf-8"?><SeatActivity xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Version="1" TimeStamp="%s" Topic="Seat" Type="SeatUpdated"><Seat Id="%d"><SeatData Name="%s" MicrophoneActive="%v" SeatType="Delegate" IsSpecialStation="false" /><Participant Id="%d"><ParticipantData Present="false" VotingWeight="1" VotingAuthorisation="true" MicrophoneAuthorisation="true" FirstName="" MiddleName="" LastName="%s" Title="" Country="" RemainingSpeechTime="-1" SpeechTimerOnHold="false" /></Participant><IsReposnding>false</IsReposnding></Seat></SeatActivity>`,
		time.Now().Format("2006-01-02T15:04:05.0000000-07:00"),
		speaker.ID,
		speaker.SeatName,
		micState,
		speaker.ParticipantID,
		speaker.SeatName,
	)

	return toUTF16LEString(xmlStr)
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å API ‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á clients
func (s *Server) ProcessAndBroadcast() {
	var lastSpeakers []Speaker
	speakerStates := make(map[int]bool)

	for {
		speakers, err := getSpeakers()
		if err != nil {
			fmt.Println("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• speakers:", err)
			// ‡∏™‡πà‡∏á XML ‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å API
			emptyXML := toUTF16LEString(fmt.Sprintf(`<?xml version="1.0" encoding="utf-8"?><DiscussionActivity xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Version="1" TimeStamp="%s" Topic="Discussion" Type="ActiveListUpdated"><Discussion Id="80"><ActiveList><Participants></Participants></ActiveList></Discussion></DiscussionActivity>`,
				time.Now().Format("2006-01-02T15:04:05.0000000-07:00")))

			header := make([]byte, 8)
			binary.LittleEndian.PutUint32(header[0:4], 3)
			binary.LittleEndian.PutUint32(header[4:8], uint32(len(emptyXML)))
			s.Broadcast(append(header, emptyXML...))
			time.Sleep(time.Second)
			continue
		}

		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ó‡∏µ‡πà‡∏ô‡∏±‡πà‡∏á
		currentSpeakerIDs := make(map[int]bool)
		for _, speaker := range speakers {
			currentSpeakerIDs[speaker.ID] = true

			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÑ‡∏°‡∏Ñ‡πå
			lastState, exists := speakerStates[speaker.ID]
			if !exists || lastState != speaker.MicOn {
				// ‡∏™‡πà‡∏á SeatActivity ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô
				seatXML := generateSeatXML(speaker, speaker.MicOn)
				header := make([]byte, 8)
				binary.LittleEndian.PutUint32(header[0:4], 5)
				binary.LittleEndian.PutUint32(header[4:8], uint32(len(seatXML)))
				s.Broadcast(append(header, seatXML...))
				speakerStates[speaker.ID] = speaker.MicOn
			}
		}

		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏ô‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡∏´‡∏≤‡∏¢‡πÑ‡∏õ
		for id, state := range speakerStates {
			if !currentSpeakerIDs[id] && state {
				// ‡∏™‡∏£‡πâ‡∏≤‡∏á speaker ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡πÅ‡∏ï‡πà‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡∏Ñ‡πå
				for _, oldSpeaker := range lastSpeakers {
					if oldSpeaker.ID == id {
						seatXML := generateSeatXML(oldSpeaker, false)
						header := make([]byte, 8)
						binary.LittleEndian.PutUint32(header[0:4], 5)
						binary.LittleEndian.PutUint32(header[4:8], uint32(len(seatXML)))
						s.Broadcast(append(header, seatXML...))
						speakerStates[id] = false
						break
					}
				}
			}
		}

		// ‡∏™‡πà‡∏á DiscussionActivity ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ô‡∏±‡πà‡∏á‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô
		if !reflect.DeepEqual(speakers, lastSpeakers) {
			discussionXML := generateDiscussionXML(speakers)
			header := make([]byte, 8)
			binary.LittleEndian.PutUint32(header[0:4], 3)
			binary.LittleEndian.PutUint32(header[4:8], uint32(len(discussionXML)))
			s.Broadcast(append(header, discussionXML...))
			lastSpeakers = speakers
		}

		time.Sleep(time.Second)
	}
}

// ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏à‡∏≤‡∏Å client
func handleClientConnection(server *Server, conn net.Conn) {
	client := server.AddClient(conn)
	defer server.RemoveClient(client.id)

	// ‡∏£‡∏≠‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤ client ‡∏à‡∏∞‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
	buffer := make([]byte, 1024)
	for {
		_, err := conn.Read(buffer)
		if err != nil {
			return
		}
	}
}

func main() {
	// ‡∏™‡∏£‡πâ‡∏≤‡∏á server
	server := NewServer()

	// ‡πÄ‡∏£‡∏¥‡πà‡∏° server
	listener, err := net.Listen("tcp", ":"+PORT)
	if err != nil {
		fmt.Printf("‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏¥‡πà‡∏° server ‡πÑ‡∏î‡πâ: %v\n", err)
		os.Exit(1)
	}
	defer listener.Close()

	fmt.Printf("üöÄ Server ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏û‡∏≠‡∏£‡πå‡∏ï %s\n", PORT)

	// ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
	go server.ProcessAndBroadcast()

	// ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏à‡∏≤‡∏Å clients
	for {
		conn, err := listener.Accept()
		if err != nil {
			fmt.Printf("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏à‡∏≤‡∏Å client ‡πÑ‡∏î‡πâ: %v\n", err)
			continue
		}
		go handleClientConnection(server, conn)
	}
}
